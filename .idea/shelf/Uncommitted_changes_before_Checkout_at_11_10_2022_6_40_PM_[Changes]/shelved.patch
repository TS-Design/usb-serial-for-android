Index: usbSerialExamples/src/main/java/com/hoho/android/usbserial/examples/TerminalFragment.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hoho.android.usbserial.examples;\r\n\r\nimport android.app.PendingIntent;\r\nimport android.content.BroadcastReceiver;\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.content.IntentFilter;\r\nimport android.hardware.usb.UsbDevice;\r\nimport android.hardware.usb.UsbDeviceConnection;\r\nimport android.hardware.usb.UsbManager;\r\nimport android.os.Build;\r\nimport android.os.Bundle;\r\nimport android.os.Handler;\r\nimport android.os.Looper;\r\nimport android.text.Spannable;\r\nimport android.text.SpannableStringBuilder;\r\nimport android.text.method.ScrollingMovementMethod;\r\nimport android.text.style.ForegroundColorSpan;\r\nimport android.view.LayoutInflater;\r\nimport android.view.Menu;\r\nimport android.view.MenuInflater;\r\nimport android.view.MenuItem;\r\nimport android.view.View;\r\nimport android.view.ViewGroup;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\nimport android.widget.ToggleButton;\r\n\r\nimport androidx.annotation.NonNull;\r\nimport androidx.annotation.Nullable;\r\nimport androidx.fragment.app.Fragment;\r\n\r\nimport com.hoho.android.usbserial.driver.UsbSerialDriver;\r\nimport com.hoho.android.usbserial.driver.UsbSerialPort;\r\nimport com.hoho.android.usbserial.driver.UsbSerialProber;\r\nimport com.hoho.android.usbserial.util.HexDump;\r\nimport com.hoho.android.usbserial.util.SerialInputOutputManager;\r\n\r\nimport java.io.IOException;\r\nimport java.util.Arrays;\r\nimport java.util.EnumSet;\r\nimport java.util.Objects;\r\n\r\npublic class TerminalFragment extends Fragment implements SerialInputOutputManager.Listener {\r\n\r\n    private enum UsbPermission { Unknown, Requested, Granted, Denied }\r\n\r\n    private static final String INTENT_ACTION_GRANT_USB = BuildConfig.APPLICATION_ID + \".GRANT_USB\";\r\n    private static final int WRITE_WAIT_MILLIS = 2000;\r\n    private static final int READ_WAIT_MILLIS = 2000;\r\n\r\n    private int deviceId, portNum, baudRate;\r\n    private boolean withIoManager;\r\n\r\n    private final BroadcastReceiver broadcastReceiver;\r\n    private final Handler mainLooper;\r\n    private TextView receiveText;\r\n    private ControlLines controlLines;\r\n\r\n    private SerialInputOutputManager usbIoManager;\r\n    private UsbSerialPort usbSerialPort;\r\n    private UsbPermission usbPermission = UsbPermission.Unknown;\r\n    private boolean connected = false;\r\n\r\n    public TerminalFragment() {\r\n        broadcastReceiver = new BroadcastReceiver() {\r\n            @Override\r\n            public void onReceive(Context context, Intent intent) {\r\n                if(INTENT_ACTION_GRANT_USB.equals(intent.getAction())) {\r\n                    usbPermission = intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)\r\n                            ? UsbPermission.Granted : UsbPermission.Denied;\r\n                    connect();\r\n                }\r\n            }\r\n        };\r\n        mainLooper = new Handler(Looper.getMainLooper());\r\n    }\r\n    /* Hoot adds */\r\n\r\n    /*\r\n     * Lifecycle\r\n     */\r\n    @Override\r\n    public void onCreate(@Nullable Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setHasOptionsMenu(true);\r\n        setRetainInstance(true);\r\n        deviceId = getArguments().getInt(\"device\");\r\n        portNum = getArguments().getInt(\"port\");\r\n        baudRate = getArguments().getInt(\"baud\");\r\n        withIoManager = getArguments().getBoolean(\"withIoManager\");\r\n    }\r\n\r\n    @Override\r\n    public void onResume() {\r\n        super.onResume();\r\n        getActivity().registerReceiver(broadcastReceiver, new IntentFilter(INTENT_ACTION_GRANT_USB));\r\n\r\n        if(usbPermission == UsbPermission.Unknown || usbPermission == UsbPermission.Granted)\r\n            mainLooper.post(this::connect);\r\n    }\r\n\r\n    @Override\r\n    public void onPause() {\r\n        if(connected) {\r\n            status(\"disconnected\");\r\n            disconnect();\r\n        }\r\n        getActivity().unregisterReceiver(broadcastReceiver);\r\n        super.onPause();\r\n    }\r\n\r\n    /*\r\n     * UI\r\n     */\r\n    @Override\r\n    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\r\n        View view = inflater.inflate(R.layout.fragment_terminal, container, false);\r\n        receiveText = view.findViewById(R.id.receive_text);                          // TextView performance decreases with number of spans\r\n        receiveText.setTextColor(getResources().getColor(R.color.colorRecieveText)); // set as default color to reduce number of spans\r\n        receiveText.setMovementMethod(ScrollingMovementMethod.getInstance());\r\n        TextView sendText = view.findViewById(R.id.send_text);\r\n        View sendBtn = view.findViewById(R.id.send_btn);\r\n        sendBtn.setOnClickListener(v -> send(sendText.getText().toString()));\r\n        View receiveBtn = view.findViewById(R.id.receive_btn);\r\n        controlLines = new ControlLines(view);\r\n        if(withIoManager) {\r\n            receiveBtn.setVisibility(View.GONE);\r\n        } else {\r\n            receiveBtn.setOnClickListener(v -> read());\r\n        }\r\n        return view;\r\n    }\r\n\r\n    @Override\r\n    public void onCreateOptionsMenu(@NonNull Menu menu, MenuInflater inflater) {\r\n        inflater.inflate(R.menu.menu_terminal, menu);\r\n    }\r\n\r\n    @Override\r\n    public boolean onOptionsItemSelected(MenuItem item) {\r\n        int id = item.getItemId();\r\n        if (id == R.id.clear) {\r\n            receiveText.setText(\"\");\r\n            return true;\r\n        } else if( id == R.id.send_break) {\r\n            if(!connected) {\r\n                Toast.makeText(getActivity(), \"not connected\", Toast.LENGTH_SHORT).show();\r\n            } else {\r\n                try {\r\n                    usbSerialPort.setBreak(true);\r\n                    Thread.sleep(100); // should show progress bar instead of blocking UI thread\r\n                    usbSerialPort.setBreak(false);\r\n                    SpannableStringBuilder spn = new SpannableStringBuilder();\r\n                    spn.append(\"send <break>\\n\");\r\n                    spn.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.colorSendText)), 0, spn.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\r\n                    receiveText.append(spn);\r\n                } catch(UnsupportedOperationException ignored) {\r\n                    Toast.makeText(getActivity(), \"BREAK not supported\", Toast.LENGTH_SHORT).show();\r\n                } catch(Exception e) {\r\n                    Toast.makeText(getActivity(), \"BREAK failed: \" + e.getMessage(), Toast.LENGTH_SHORT).show();\r\n                }\r\n            }\r\n            return true;\r\n        } else {\r\n            return super.onOptionsItemSelected(item);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Serial\r\n     */\r\n    @Override\r\n    public void onNewData(byte[] data) {\r\n        mainLooper.post(() -> {\r\n            receive(data);\r\n        });\r\n    }\r\n\r\n    @Override\r\n    public void onRunError(Exception e) {\r\n        mainLooper.post(() -> {\r\n            status(\"connection lost: \" + e.getMessage());\r\n            disconnect();\r\n        });\r\n    }\r\n\r\n    /*\r\n     * Serial + UI\r\n     */\r\n    private void connect() {\r\n        UsbDevice device = null;\r\n        UsbManager usbManager = (UsbManager) getActivity().getSystemService(Context.USB_SERVICE);\r\n        for(UsbDevice v : usbManager.getDeviceList().values())\r\n            if(v.getDeviceId() == deviceId)\r\n                device = v;\r\n        if(device == null) {\r\n            status(\"connection failed: device not found\");\r\n            return;\r\n        }\r\n        UsbSerialDriver driver = UsbSerialProber.getDefaultProber().probeDevice(device);\r\n        if(driver == null) {\r\n            driver = CustomProber.getCustomProber().probeDevice(device);\r\n        }\r\n        if(driver == null) {\r\n            status(\"connection failed: no driver for device\");\r\n            return;\r\n        }\r\n        if(driver.getPorts().size() < portNum) {\r\n            status(\"connection failed: not enough ports at device\");\r\n            return;\r\n        }\r\n        usbSerialPort = driver.getPorts().get(portNum);\r\n        UsbDeviceConnection usbConnection = usbManager.openDevice(driver.getDevice());\r\n        if(usbConnection == null && usbPermission == UsbPermission.Unknown && !usbManager.hasPermission(driver.getDevice())) {\r\n            usbPermission = UsbPermission.Requested;\r\n            int flags = Build.VERSION.SDK_INT >= Build.VERSION_CODES.M ? PendingIntent.FLAG_IMMUTABLE : 0;\r\n            PendingIntent usbPermissionIntent = PendingIntent.getBroadcast(getActivity(), 0, new Intent(INTENT_ACTION_GRANT_USB), flags);\r\n            usbManager.requestPermission(driver.getDevice(), usbPermissionIntent);\r\n            return;\r\n        }\r\n        if(usbConnection == null) {\r\n            if (!usbManager.hasPermission(driver.getDevice()))\r\n                status(\"connection failed: permission denied\");\r\n            else\r\n                status(\"connection failed: open failed\");\r\n            return;\r\n        }\r\n\r\n        try {\r\n            usbSerialPort.open(usbConnection);\r\n            usbSerialPort.setParameters(baudRate, 8, 1, UsbSerialPort.PARITY_NONE);\r\n            if(withIoManager) {\r\n                usbIoManager = new SerialInputOutputManager(usbSerialPort, this);\r\n                usbIoManager.start();\r\n            }\r\n            status(\"connected\");\r\n            connected = true;\r\n            controlLines.start();\r\n        } catch (Exception e) {\r\n            status(\"connection failed: \" + e.getMessage());\r\n            disconnect();\r\n        }\r\n    }\r\n\r\n    private void disconnect() {\r\n        connected = false;\r\n        controlLines.stop();\r\n        if(usbIoManager != null) {\r\n            usbIoManager.setListener(null);\r\n            usbIoManager.stop();\r\n        }\r\n        usbIoManager = null;\r\n        try {\r\n            usbSerialPort.close();\r\n        } catch (IOException ignored) {}\r\n        usbSerialPort = null;\r\n    }\r\n\r\n    private void send(String str) {\r\n        if(!connected) {\r\n            Toast.makeText(getActivity(), \"not connected\", Toast.LENGTH_SHORT).show();\r\n            return;\r\n        }\r\n        try {\r\n        byte[] data = (str + '\\n').getBytes();\r\n            SpannableStringBuilder spn = new SpannableStringBuilder();\r\n            spn.append(\"send \" + data.length + \" bytes\\n\");\r\n            spn.append(HexDump.dumpHexString(data)).append(\"\\n\");\r\n            spn.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.colorSendText)), 0, spn.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\r\n            receiveText.append(spn);\r\n            usbSerialPort.write(data, WRITE_WAIT_MILLIS);\r\n        } catch (Exception e) {\r\n            onRunError(e);\r\n        }\r\n    }\r\n\r\n    private void read() {\r\n        if(!connected) {\r\n            Toast.makeText(getActivity(), \"not connected\", Toast.LENGTH_SHORT).show();\r\n            return;\r\n        }\r\n        try {\r\n            byte[] buffer = new byte[8192];\r\n            int len = usbSerialPort.read(buffer, READ_WAIT_MILLIS);\r\n            receive(Arrays.copyOf(buffer, len));\r\n        } catch (IOException e) {\r\n            // when using read with timeout, USB bulkTransfer returns -1 on timeout _and_ errors\r\n            // like connection loss, so there is typically no exception thrown here on error\r\n            status(\"connection lost: \" + e.getMessage());\r\n            disconnect();\r\n        }\r\n    }\r\n\r\n    private void receive(byte[] data) {\r\n        SpannableStringBuilder spn = new SpannableStringBuilder();\r\n        if(data.length > 0)\r\n        {\r\n            spn.append(\"receive \" + data.length + \" bytes\\n\");\r\n            spn.append(HexDump.dumpHexString(data)).append(\"\\n\");\r\n            parse(data);\r\n        }\r\n        //receiveText.append(spn);\r\n    }\r\n\r\n    private void parse(byte[] data)\r\n    {\r\n        String rx = new String(data);\r\n        //SpannableStringBuilder rx = new SpannableStringBuilder(null);\r\n        String keyString = \"\";\r\n        String KEY = null;\r\n        String VALUE;\r\n\r\n        if(rx.length() > 0) {\r\n            for(int k = 0; k < rx.length(); k++){\r\n                receiveText.append(String.valueOf(rx.charAt(k)));\r\n                switch(rx.charAt(k)) {\r\n                    case '{':\r\n                        keyString = \"\";\r\n                        break;\r\n                    case '}':\r\n                        VALUE = keyString;\r\n                        keyString = \"\";\r\n                        receiveText.append(\"--\" + KEY + \":\" + VALUE +  \"\\n\");\r\n                        break;\r\n                    case ':':\r\n                        KEY = keyString;\r\n                        keyString = \"\";\r\n                        break;\r\n                    case '\"':\r\n                    case '\\n':\r\n                    case '\\r':\r\n                    case ' ':\r\n                        break;\r\n                    default:\r\n                        keyString = keyString.concat(String.valueOf(rx.charAt(k)));\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    void status(String str) {\r\n        SpannableStringBuilder spn = new SpannableStringBuilder(str+'\\n');\r\n        spn.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.colorStatusText)), 0, spn.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\r\n        receiveText.append(spn);\r\n    }\r\n\r\n    class ControlLines {\r\n        private static final int refreshInterval = 200; // msec\r\n\r\n        private final Runnable runnable;\r\n        private final ToggleButton rtsBtn, ctsBtn, dtrBtn, dsrBtn, cdBtn, riBtn;\r\n\r\n        ControlLines(View view) {\r\n            runnable = this::run; // w/o explicit Runnable, a new lambda would be created on each postDelayed, which would not be found again by removeCallbacks\r\n\r\n            rtsBtn = view.findViewById(R.id.controlLineRts);\r\n            ctsBtn = view.findViewById(R.id.controlLineCts);\r\n            dtrBtn = view.findViewById(R.id.controlLineDtr);\r\n            dsrBtn = view.findViewById(R.id.controlLineDsr);\r\n            cdBtn = view.findViewById(R.id.controlLineCd);\r\n            riBtn = view.findViewById(R.id.controlLineRi);\r\n            rtsBtn.setOnClickListener(this::toggle);\r\n            dtrBtn.setOnClickListener(this::toggle);\r\n        }\r\n\r\n        private void toggle(View v) {\r\n            ToggleButton btn = (ToggleButton) v;\r\n            if (!connected) {\r\n                btn.setChecked(!btn.isChecked());\r\n                Toast.makeText(getActivity(), \"not connected\", Toast.LENGTH_SHORT).show();\r\n                return;\r\n            }\r\n            String ctrl = \"\";\r\n            try {\r\n                if (btn.equals(rtsBtn)) { ctrl = \"RTS\"; usbSerialPort.setRTS(btn.isChecked()); }\r\n                if (btn.equals(dtrBtn)) { ctrl = \"DTR\"; usbSerialPort.setDTR(btn.isChecked()); }\r\n            } catch (IOException e) {\r\n                status(\"set\" + ctrl + \"() failed: \" + e.getMessage());\r\n            }\r\n        }\r\n\r\n        private void run() {\r\n            if (!connected)\r\n                return;\r\n            try {\r\n                EnumSet<UsbSerialPort.ControlLine> controlLines = usbSerialPort.getControlLines();\r\n                rtsBtn.setChecked(controlLines.contains(UsbSerialPort.ControlLine.RTS));\r\n                ctsBtn.setChecked(controlLines.contains(UsbSerialPort.ControlLine.CTS));\r\n                dtrBtn.setChecked(controlLines.contains(UsbSerialPort.ControlLine.DTR));\r\n                dsrBtn.setChecked(controlLines.contains(UsbSerialPort.ControlLine.DSR));\r\n                cdBtn.setChecked(controlLines.contains(UsbSerialPort.ControlLine.CD));\r\n                riBtn.setChecked(controlLines.contains(UsbSerialPort.ControlLine.RI));\r\n                mainLooper.postDelayed(runnable, refreshInterval);\r\n            } catch (IOException e) {\r\n                status(\"getControlLines() failed: \" + e.getMessage() + \" -> stopped control line refresh\");\r\n            }\r\n        }\r\n\r\n        void start() {\r\n            if (!connected)\r\n                return;\r\n            try {\r\n                EnumSet<UsbSerialPort.ControlLine> controlLines = usbSerialPort.getSupportedControlLines();\r\n                if (!controlLines.contains(UsbSerialPort.ControlLine.RTS)) rtsBtn.setVisibility(View.INVISIBLE);\r\n                if (!controlLines.contains(UsbSerialPort.ControlLine.CTS)) ctsBtn.setVisibility(View.INVISIBLE);\r\n                if (!controlLines.contains(UsbSerialPort.ControlLine.DTR)) dtrBtn.setVisibility(View.INVISIBLE);\r\n                if (!controlLines.contains(UsbSerialPort.ControlLine.DSR)) dsrBtn.setVisibility(View.INVISIBLE);\r\n                if (!controlLines.contains(UsbSerialPort.ControlLine.CD))   cdBtn.setVisibility(View.INVISIBLE);\r\n                if (!controlLines.contains(UsbSerialPort.ControlLine.RI))   riBtn.setVisibility(View.INVISIBLE);\r\n                run();\r\n            } catch (IOException e) {\r\n                Toast.makeText(getActivity(), \"getSupportedControlLines() failed: \" + e.getMessage(), Toast.LENGTH_SHORT).show();\r\n            }\r\n        }\r\n\r\n        void stop() {\r\n            mainLooper.removeCallbacks(runnable);\r\n            rtsBtn.setChecked(false);\r\n            ctsBtn.setChecked(false);\r\n            dtrBtn.setChecked(false);\r\n            dsrBtn.setChecked(false);\r\n            cdBtn.setChecked(false);\r\n            riBtn.setChecked(false);\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/usbSerialExamples/src/main/java/com/hoho/android/usbserial/examples/TerminalFragment.java b/usbSerialExamples/src/main/java/com/hoho/android/usbserial/examples/TerminalFragment.java
--- a/usbSerialExamples/src/main/java/com/hoho/android/usbserial/examples/TerminalFragment.java	
+++ b/usbSerialExamples/src/main/java/com/hoho/android/usbserial/examples/TerminalFragment.java	
@@ -61,6 +61,10 @@
     private UsbSerialPort usbSerialPort;
     private UsbPermission usbPermission = UsbPermission.Unknown;
     private boolean connected = false;
+/* Hoot Adds */
+    static String keyString = "";
+    static String KEY = null;
+    static String VALUE;
 
     public TerminalFragment() {
         broadcastReceiver = new BroadcastReceiver() {
@@ -306,14 +310,8 @@
     private void parse(byte[] data)
     {
         String rx = new String(data);
-        //SpannableStringBuilder rx = new SpannableStringBuilder(null);
-        String keyString = "";
-        String KEY = null;
-        String VALUE;
-
         if(rx.length() > 0) {
             for(int k = 0; k < rx.length(); k++){
-                receiveText.append(String.valueOf(rx.charAt(k)));
                 switch(rx.charAt(k)) {
                     case '{':
                         keyString = "";
Index: usbSerialExamples/src/main/java/com/hoho/android/usbserial/examples/MainActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hoho.android.usbserial.examples;\r\n\r\nimport android.content.Intent;\r\nimport android.os.Bundle;\r\nimport androidx.fragment.app.FragmentManager;\r\nimport androidx.appcompat.app.AppCompatActivity;\r\nimport androidx.appcompat.widget.Toolbar;\r\n\r\npublic class MainActivity extends AppCompatActivity implements FragmentManager.OnBackStackChangedListener {\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_main);\r\n        Toolbar toolbar = findViewById(R.id.toolbar);\r\n        setSupportActionBar(toolbar);\r\n        getSupportFragmentManager().addOnBackStackChangedListener(this);\r\n        if (savedInstanceState == null)\r\n            getSupportFragmentManager().beginTransaction().add(R.id.fragment, new DevicesFragment(), \"devices\").commit();\r\n        else\r\n            onBackStackChanged();\r\n    }\r\n\r\n    @Override\r\n    public void onBackStackChanged() {\r\n        getSupportActionBar().setDisplayHomeAsUpEnabled(getSupportFragmentManager().getBackStackEntryCount()>0);\r\n    }\r\n\r\n    @Override\r\n    public boolean onSupportNavigateUp() {\r\n        onBackPressed();\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    protected void onNewIntent(Intent intent) {\r\n        if(\"android.hardware.usb.action.USB_DEVICE_ATTACHED\".equals(intent.getAction())) {\r\n            TerminalFragment terminal = (TerminalFragment)getSupportFragmentManager().findFragmentByTag(\"terminal\");\r\n            if (terminal != null)\r\n                terminal.status(\"USB device detected\");\r\n        }\r\n        super.onNewIntent(intent);\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/usbSerialExamples/src/main/java/com/hoho/android/usbserial/examples/MainActivity.java b/usbSerialExamples/src/main/java/com/hoho/android/usbserial/examples/MainActivity.java
--- a/usbSerialExamples/src/main/java/com/hoho/android/usbserial/examples/MainActivity.java	
+++ b/usbSerialExamples/src/main/java/com/hoho/android/usbserial/examples/MainActivity.java	
@@ -15,9 +15,10 @@
         Toolbar toolbar = findViewById(R.id.toolbar);
         setSupportActionBar(toolbar);
         getSupportFragmentManager().addOnBackStackChangedListener(this);
-        if (savedInstanceState == null)
+        if (savedInstanceState == null) {
             getSupportFragmentManager().beginTransaction().add(R.id.fragment, new DevicesFragment(), "devices").commit();
-        else
+            getSupportFragmentManager().beginTransaction().add(R.id.home, new DevicesFragment(), "home").commit();
+        } else
             onBackStackChanged();
     }
 
Index: usbSerialExamples/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>plugins {\r\n    id 'com.android.application'\r\n}\r\n\r\nandroid {\r\n    compileSdkVersion 32\r\n\r\n    compileOptions {\r\n        sourceCompatibility JavaVersion.VERSION_1_8\r\n        targetCompatibility JavaVersion.VERSION_1_8\r\n    }\r\n\r\n    defaultConfig {\r\n        minSdkVersion 17\r\n        targetSdkVersion 32\r\n        vectorDrawables.useSupportLibrary = true\r\n\r\n        missingDimensionStrategy 'device', 'anyDevice'\r\n    }\r\n\r\n    buildTypes {\r\n        release {\r\n            minifyEnabled true\r\n        }\r\n    }\r\n}\r\n\r\ndependencies {\r\n    implementation project(':usbSerialForAndroid')\r\n    implementation 'androidx.appcompat:appcompat:1.5.1'\r\n    implementation 'com.google.android.material:material:1.7.0'\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/usbSerialExamples/build.gradle b/usbSerialExamples/build.gradle
--- a/usbSerialExamples/build.gradle	
+++ b/usbSerialExamples/build.gradle	
@@ -11,7 +11,7 @@
     }
 
     defaultConfig {
-        minSdkVersion 17
+        minSdkVersion 26
         targetSdkVersion 32
         vectorDrawables.useSupportLibrary = true
 
